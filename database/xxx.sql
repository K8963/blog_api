/*
 Navicat Premium Data Transfer

 Source Server         : 8963
 Source Server Type    : MySQL
 Source Server Version : 50726
 Source Host           : localhost:3306
 Source Schema         : laravel_api

 Target Server Type    : MySQL
 Target Server Version : 50726
 File Encoding         : 65001

 Date: 17/08/2020 23:08:21
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '标题',
  `outline` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '文章概要',
  `author` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '作者',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '内容markdown',
  `html` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '内容html',
  `sort` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '类别',
  `tag` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '标签',
  `created_at` timestamp(0) NULL DEFAULT NULL,
  `updated_at` timestamp(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 14 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (2, 'Rollup.js：开源JS库的打包利器', 'Rollup 是一个 JavaScript 模块打包器，说到模块打包器，自然就会想到 webpack。webpack 是一个现代 JavaScript 应用程序的静态模块打包器，那么在 webpack 已经成为前端构建主流的今天，为什么还要用 Rollup 呢？', '8963', 'vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。\r\n\r\n浏览器无情地抛出了一个错误：\r\n\r\n```\r\nUncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n```\r\n\r\n\r\n不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的\r\n## 插件实现\r\n### 基本框架\r\n\r\n下面先实现一个插件的基本框架。\r\n\r\n```\r\nimport { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () => {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n', '<p>在信息安全越来越受重视的今天，前端的各种加密也变得更加重要。通常跟服务器的交互中，为保障数据传输的安全性，避免被人抓包篡改数据，除了 https 的应用，还需要对传输数据进行加解密。</p>\n<p>目前常见的加密算法可以分成三类</p>\n<ul>\n<li>对称加密算法：AES、…</li>\n<li>非对称加密算法：RSA、…</li>\n<li>Hash 算法：MD5、…</li>\n</ul>\n<p><strong>二、对称加密算法</strong><br />\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。</p>\n<p><strong>特点</strong><br />\n优点：算法公开、计算量小、加密速度快、加密效率高。<br />\n缺点：在数据传送前，发送方和接收方必须商定好密钥，然后双方保存好密钥。如果一方的密钥被泄露，那么加密信息也就不安全了<br />\n使用场景：本地数据加密、https 通信、网络传输等<br />\n<strong>AES</strong><br />\nAES：高级加密标准(Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。<br />\n密钥：用来加密明文的密码。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取数据。</p>', '后端', 'Javascript,JAVA', '2020-08-12 11:47:25', NULL);
INSERT INTO `article` VALUES (3, 'PHP 插件开发详解尝鲜版', '虽然网上有很多的 gulp 构建文章，但是很多都已经随着 gulp 插件的更新无法运行了。因此，我写了这个比较简单的构建方案。本文基于 gulp 最新的 4.0.2 版本进行了修改。现在前端组件化项目大多是基于 webpack 进行构建，但是有一个零散的小业务，静态页面之类的，使用 gulp 反而会更加简单方便。', '8963', '<p>在信息安全越来越受重视的今天，前端的各种加密也变得更加重要。通常跟服务器的交互中，为保障数据传输的安全性，避免被人抓包篡改数据，除了 https 的应用，还需要对传输数据进行加解密。</p>\n<p>目前常见的加密算法可以分成三类</p>\n<ul>\n<li>对称加密算法：AES、…</li>\n<li>非对称加密算法：RSA、…</li>\n<li>Hash 算法：MD5、…</li>\n</ul>\n<p><strong>二、对称加密算法</strong><br />\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。</p>\n<p><strong>特点</strong><br />\n优点：算法公开、计算量小、加密速度快、加密效率高。<br />\n缺点：在数据传送前，发送方和接收方必须商定好密钥，然后双方保存好密钥。如果一方的密钥被泄露，那么加密信息也就不安全了<br />\n使用场景：本地数据加密、https 通信、网络传输等<br />\n<strong>AES</strong><br />\nAES：高级加密标准(Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。<br />\n密钥：用来加密明文的密码。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取数据。</p>', '<p>在信息安全越来越受重视的今天，前端的各种加密也变得更加重要。通常跟服务器的交互中，为保障数据传输的安全性，避免被人抓包篡改数据，除了 https 的应用，还需要对传输数据进行加解密。</p>\n<p>目前常见的加密算法可以分成三类</p>\n<ul>\n<li>对称加密算法：AES、…</li>\n<li>非对称加密算法：RSA、…</li>\n<li>Hash 算法：MD5、…</li>\n</ul>\n<p><strong>二、对称加密算法</strong><br />\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。</p>\n<p><strong>特点</strong><br />\n优点：算法公开、计算量小、加密速度快、加密效率高。<br />\n缺点：在数据传送前，发送方和接收方必须商定好密钥，然后双方保存好密钥。如果一方的密钥被泄露，那么加密信息也就不安全了<br />\n使用场景：本地数据加密、https 通信、网络传输等<br />\n<strong>AES</strong><br />\nAES：高级加密标准(Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。<br />\n密钥：用来加密明文的密码。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取数据。</p>', '服务端', 'PHP', '2020-01-12 11:47:25', NULL);
INSERT INTO `article` VALUES (4, '前端常见的加密算法介绍', 'Rollup 是一个 JavaScript 模块打包器，说到模块打包器，自然就会想到 webpack。webpack 是一个现代 JavaScript 应用程序的静态模块打包器，那么在 webpack 已经成为前端构建主流的今天，为什么还要用 Rollup 呢？', '8963', 'vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。\r\n\r\n浏览器无情地抛出了一个错误：\r\n\r\n```\r\nUncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n```\r\n\r\n\r\n不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的\r\n## 插件实现\r\n### 基本框架\r\n\r\n下面先实现一个插件的基本框架。\r\n\r\n```\r\nimport { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () => {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n', '<p>vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。</p>\r\n<p>浏览器无情地抛出了一个错误：</p>\r\n<pre><code class=\"lang-\">Uncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n</code></pre>\r\n<p>不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的</p>\r\n<h2><a id=\"_10\"></a>插件实现</h2>\r\n<h3><a id=\"_11\"></a>基本框架</h3>\r\n<p>下面先实现一个插件的基本框架。</p>\r\n<pre><code class=\"lang-\">import { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () =&gt; {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n</code></pre>\r\n<p>在信息安全越来越受重视的今天，前端的各种加密也变得更加重要。通常跟服务器的交互中，为保障数据传输的安全性，避免被人抓包篡改数据，除了 https 的应用，还需要对传输数据进行加解密。</p>\n<p>目前常见的加密算法可以分成三类</p>\n<ul>\n<li>对称加密算法：AES、…</li>\n<li>非对称加密算法：RSA、…</li>\n<li>Hash 算法：MD5、…</li>\n</ul>\n<p><strong>二、对称加密算法</strong><br />\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。</p>\n<p><strong>特点</strong><br />\n优点：算法公开、计算量小、加密速度快、加密效率高。<br />\n缺点：在数据传送前，发送方和接收方必须商定好密钥，然后双方保存好密钥。如果一方的密钥被泄露，那么加密信息也就不安全了<br />\n使用场景：本地数据加密、https 通信、网络传输等<br />\n<strong>AES</strong><br />\nAES：高级加密标准(Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。<br />\n密钥：用来加密明文的密码。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取数据。</p>', '前端', 'HTMl,CSS,Python', '2020-02-12 11:47:25', NULL);
INSERT INTO `article` VALUES (5, 'Rollup.js：开源JS库的打包利器', '虽然网上有很多的 gulp 构建文章，但是很多都已经随着 gulp 插件的更新无法运行了。因此，我写了这个比较简单的构建方案。本文基于 gulp 最新的 4.0.2 版本进行了修改。现在前端组件化项目大多是基于 webpack 进行构建，但是有一个零散的小业务，静态页面之类的，使用 gulp 反而会更加简单方便。', '8963', 'vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。\r\n\r\n浏览器无情地抛出了一个错误：\r\n\r\n```\r\nUncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n```\r\n\r\n\r\n不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的\r\n## 插件实现\r\n### 基本框架\r\n\r\n下面先实现一个插件的基本框架。\r\n\r\n```\r\nimport { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () => {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n', '<p>vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。</p>\r\n<p>浏览器无情地抛出了一个错误：</p>\r\n<pre><code class=\"lang-\">Uncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n</code></pre>\r\n<p>不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的</p>\r\n<h2><a id=\"_10\"></a>插件实现</h2>\r\n<h3><a id=\"_11\"></a>基本框架</h3>\r\n<p>下面先实现一个插件的基本框架。</p>\r\n<pre><code class=\"lang-\">import { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () =&gt; {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n</code></pre>\r\n', '服务端', 'PHP,HTMl,Mysql', '2020-03-12 11:47:25', NULL);
INSERT INTO `article` VALUES (6, '前端常见的加密算法介绍', 'Rollup 是一个 JavaScript 模块打包器，说到模块打包器，自然就会想到 webpack。webpack 是一个现代 JavaScript 应用程序的静态模块打包器，那么在 webpack 已经成为前端构建主流的今天，为什么还要用 Rollup 呢？', '8963', 'vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。\r\n\r\n浏览器无情地抛出了一个错误：\r\n\r\n```\r\nUncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n```\r\n\r\n\r\n不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的\r\n## 插件实现\r\n### 基本框架\r\n\r\n下面先实现一个插件的基本框架。\r\n\r\n```\r\nimport { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () => {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n', '<p>在信息安全越来越受重视的今天，前端的各种加密也变得更加重要。通常跟服务器的交互中，为保障数据传输的安全性，避免被人抓包篡改数据，除了 https 的应用，还需要对传输数据进行加解密。</p>\n<p>目前常见的加密算法可以分成三类</p>\n<ul>\n<li>对称加密算法：AES、…</li>\n<li>非对称加密算法：RSA、…</li>\n<li>Hash 算法：MD5、…</li>\n</ul>\n<p><strong>二、对称加密算法</strong><br />\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。</p>\n<p><strong>特点</strong><br />\n优点：算法公开、计算量小、加密速度快、加密效率高。<br />\n缺点：在数据传送前，发送方和接收方必须商定好密钥，然后双方保存好密钥。如果一方的密钥被泄露，那么加密信息也就不安全了<br />\n使用场景：本地数据加密、https 通信、网络传输等<br />\n<strong>AES</strong><br />\nAES：高级加密标准(Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。<br />\n密钥：用来加密明文的密码。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取数据。</p>', '后端', 'Python', '2020-04-12 11:47:25', NULL);
INSERT INTO `article` VALUES (7, 'Vue3 插件开发详解尝鲜版', '虽然网上有很多的 gulp 构建文章，但是很多都已经随着 gulp 插件的更新无法运行了。因此，我写了这个比较简单的构建方案。本文基于 gulp 最新的 4.0.2 版本进行了修改。现在前端组件化项目大多是基于 webpack 进行构建，但是有一个零散的小业务，静态页面之类的，使用 gulp 反而会更加简单方便。', '8963', 'vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。\r\n\r\n浏览器无情地抛出了一个错误：\r\n\r\n```\r\nUncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n```\r\n\r\n\r\n不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的\r\n## 插件实现\r\n### 基本框架\r\n\r\n下面先实现一个插件的基本框架。\r\n\r\n```\r\nimport { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () => {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n', '<p>vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。</p>\r\n<p>浏览器无情地抛出了一个错误：</p>\r\n<pre><code class=\"lang-\">Uncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n</code></pre>\r\n<p>不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的</p>\r\n<h2><a id=\"_10\"></a>插件实现</h2>\r\n<h3><a id=\"_11\"></a>基本框架</h3>\r\n<p>下面先实现一个插件的基本框架。</p>\r\n<pre><code class=\"lang-\">import { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () =&gt; {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n</code></pre><p>在信息安全越来越受重视的今天，前端的各种加密也变得更加重要。通常跟服务器的交互中，为保障数据传输的安全性，避免被人抓包篡改数据，除了 https 的应用，还需要对传输数据进行加解密。</p>\n<p>目前常见的加密算法可以分成三类</p>\n<ul>\n<li>对称加密算法：AES、…</li>\n<li>非对称加密算法：RSA、…</li>\n<li>Hash 算法：MD5、…</li>\n</ul>\n<p><strong>二、对称加密算法</strong><br />\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。</p>\n<p><strong>特点</strong><br />\n优点：算法公开、计算量小、加密速度快、加密效率高。<br />\n缺点：在数据传送前，发送方和接收方必须商定好密钥，然后双方保存好密钥。如果一方的密钥被泄露，那么加密信息也就不安全了<br />\n使用场景：本地数据加密、https 通信、网络传输等<br />\n<strong>AES</strong><br />\nAES：高级加密标准(Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。<br />\n密钥：用来加密明文的密码。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取数据。</p>', '前端', 'PHP,Python', '2020-05-12 11:47:25', NULL);
INSERT INTO `article` VALUES (8, '前端常见的加密算法介绍', 'Rollup 是一个 JavaScript 模块打包器，说到模块打包器，自然就会想到 webpack。webpack 是一个现代 JavaScript 应用程序的静态模块打包器，那么在 webpack 已经成为前端构建主流的今天，为什么还要用 Rollup 呢？', '8963', 'vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。\r\n\r\n浏览器无情地抛出了一个错误：\r\n\r\n```\r\nUncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n```\r\n\r\n\r\n不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的\r\n## 插件实现\r\n### 基本框架\r\n\r\n下面先实现一个插件的基本框架。\r\n\r\n```\r\nimport { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () => {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n', '<p>在信息安全越来越受重视的今天，前端的各种加密也变得更加重要。通常跟服务器的交互中，为保障数据传输的安全性，避免被人抓包篡改数据，除了 https 的应用，还需要对传输数据进行加解密。</p>\n<p>目前常见的加密算法可以分成三类</p>\n<ul>\n<li>对称加密算法：AES、…</li>\n<li>非对称加密算法：RSA、…</li>\n<li>Hash 算法：MD5、…</li>\n</ul>\n<p><strong>二、对称加密算法</strong><br />\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。</p>\n<p><strong>特点</strong><br />\n优点：算法公开、计算量小、加密速度快、加密效率高。<br />\n缺点：在数据传送前，发送方和接收方必须商定好密钥，然后双方保存好密钥。如果一方的密钥被泄露，那么加密信息也就不安全了<br />\n使用场景：本地数据加密、https 通信、网络传输等<br />\n<strong>AES</strong><br />\nAES：高级加密标准(Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。<br />\n密钥：用来加密明文的密码。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取数据。</p>', '服务端', 'HTMl', '2020-06-12 11:47:25', NULL);
INSERT INTO `article` VALUES (9, 'Vue3 插件开发详解尝鲜版', '像我们熟悉的 vue-cli，react-native-cli 等脚手架，只需要输入简单的命令 vue init webpack project，即可快速帮我们生成一个初始项目。在实际工作中，我们可以定制一个属于自己的脚手架，来提高自己的工作效率。', '8963', 'vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。\r\n\r\n浏览器无情地抛出了一个错误：\r\n\r\n```\r\nUncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n```\r\n\r\n\r\n不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的\r\n## 插件实现\r\n### 基本框架\r\n\r\n下面先实现一个插件的基本框架。\r\n\r\n```\r\nimport { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () => {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n', '<p>vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。</p>\r\n<p>浏览器无情地抛出了一个错误：</p>\r\n<pre><code class=\"lang-\">Uncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n</code></pre>\r\n<p>不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的</p>\r\n<h2><a id=\"_10\"></a>插件实现</h2>\r\n<h3><a id=\"_11\"></a>基本框架</h3>\r\n<p>下面先实现一个插件的基本框架。</p>\r\n<pre><code class=\"lang-\">import { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () =&gt; {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n</code></pre>\r\n', '后端', 'PHP,JavaScript', '2020-07-12 11:47:25', NULL);
INSERT INTO `article` VALUES (10, 'Rollup.js：开源JS库的打包利器', '虽然网上有很多的 gulp 构建文章，但是很多都已经随着 gulp 插件的更新无法运行了。因此，我写了这个比较简单的构建方案。本文基于 gulp 最新的 4.0.2 版本进行了修改。现在前端组件化项目大多是基于 webpack 进行构建，但是有一个零散的小业务，静态页面之类的，使用 gulp 反而会更加简单方便。', '8963', 'vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。\r\n\r\n浏览器无情地抛出了一个错误：\r\n\r\n```\r\nUncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n```\r\n\r\n\r\n不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的\r\n## 插件实现\r\n### 基本框架\r\n\r\n下面先实现一个插件的基本框架。\r\n\r\n```\r\nimport { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () => {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n', '<p>在信息安全越来越受重视的今天，前端的各种加密也变得更加重要。通常跟服务器的交互中，为保障数据传输的安全性，避免被人抓包篡改数据，除了 https 的应用，还需要对传输数据进行加解密。</p>\n<p>目前常见的加密算法可以分成三类</p>\n<ul>\n<li>对称加密算法：AES、…</li>\n<li>非对称加密算法：RSA、…</li>\n<li>Hash 算法：MD5、…</li>\n</ul>\n<p><strong>二、对称加密算法</strong><br />\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。</p>\n<p><strong>特点</strong><br />\n优点：算法公开、计算量小、加密速度快、加密效率高。<br />\n缺点：在数据传送前，发送方和接收方必须商定好密钥，然后双方保存好密钥。如果一方的密钥被泄露，那么加密信息也就不安全了<br />\n使用场景：本地数据加密、https 通信、网络传输等<br />\n<strong>AES</strong><br />\nAES：高级加密标准(Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。<br />\n密钥：用来加密明文的密码。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取数据。</p>', '服务端', 'HTMl,Mysql', '2020-08-12 11:47:25', NULL);
INSERT INTO `article` VALUES (11, '前端常见的加密算法介绍', '像我们熟悉的 vue-cli，react-native-cli 等脚手架，只需要输入简单的命令 vue init webpack project，即可快速帮我们生成一个初始项目。在实际工作中，我们可以定制一个属于自己的脚手架，来提高自己的工作效率。', '8963', 'vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。\r\n\r\n浏览器无情地抛出了一个错误：\r\n\r\n```\r\nUncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n```\r\n\r\n\r\n不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的\r\n## 插件实现\r\n### 基本框架\r\n\r\n下面先实现一个插件的基本框架。\r\n\r\n```\r\nimport { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () => {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n', '<p>vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。</p>\r\n<p>浏览器无情地抛出了一个错误：</p>\r\n<pre><code class=\"lang-\">Uncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n</code></pre>\r\n<p>不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的</p>\r\n<h2><a id=\"_10\"></a>插件实现</h2>\r\n<h3><a id=\"_11\"></a>基本框架</h3>\r\n<p>下面先实现一个插件的基本框架。</p>\r\n<pre><code class=\"lang-\">import { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () =&gt; {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n</code></pre>\r\n', '后端', 'HTMl', '2020-08-12 11:47:25', NULL);
INSERT INTO `article` VALUES (12, 'Vue3 插件开发详解尝鲜版', 'Rollup 是一个 JavaScript 模块打包器，说到模块打包器，自然就会想到 webpack。webpack 是一个现代 JavaScript 应用程序的静态模块打包器，那么在 webpack 已经成为前端构建主流的今天，为什么还要用 Rollup 呢？', '8963', 'vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。\r\n\r\n浏览器无情地抛出了一个错误：\r\n\r\n```\r\nUncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n```\r\n\r\n\r\n不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的\r\n## 插件实现\r\n### 基本框架\r\n\r\n下面先实现一个插件的基本框架。\r\n\r\n```\r\nimport { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () => {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n', '<p>vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。</p>\r\n<p>浏览器无情地抛出了一个错误：</p>\r\n<pre><code class=\"lang-\">Uncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n</code></pre>\r\n<p>不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的</p>\r\n<h2><a id=\"_10\"></a>插件实现</h2>\r\n<h3><a id=\"_11\"></a>基本框架</h3>\r\n<p>下面先实现一个插件的基本框架。</p>\r\n<pre><code class=\"lang-\">import { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () =&gt; {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n</code></pre>\r\n', '前端', 'PHP,Mysql', '2020-01-12 11:47:25', NULL);
INSERT INTO `article` VALUES (13, 'Rollup.js：开源JS库的打包利器', '像我们熟悉的 vue-cli，react-native-cli 等脚手架，只需要输入简单的命令 vue init webpack project，即可快速帮我们生成一个初始项目。在实际工作中，我们可以定制一个属于自己的脚手架，来提高自己的工作效率。', '8963', 'vue3.0-beta 版本已经发布了一段时间了，正式版本据说在年中发布（直播的时候说的是年中还是年终，网上传闻说是 6 月份）。嘴上说着学不动，身体却很诚实地创建一个 vue3 的项目，兴致勃勃地引入 vue2 插件的时候，眉头一皱，发现事情并没有那么简单。\r\n\r\n浏览器无情地抛出了一个错误：\r\n\r\n```\r\nUncaught TypeError: Cannot set property ‘\\$toast’ of undefined\r\n```\r\n\r\n\r\n不是说兼容 vue2 的写法吗，插件不兼容，这是闹哪样？发下牢骚之后还是得解决问题。研究插件的代码，是这么实现的\r\n## 插件实现\r\n### 基本框架\r\n\r\n下面先实现一个插件的基本框架。\r\n\r\n```\r\nimport { provide, inject } from \'vue\';\r\nconst ToastSymbol = Symbol(); 	// 用Symbol创建一个唯一标识，多个插件之间不会冲突\r\nconst _toast = () => {}		// 插件的主体方法\r\nexport function provideToast(config) {	// 对外暴露的方法，将 _toast 方法提供给后代组件\r\n    provide(ToastSymbol, _toast);\r\n}\r\nexport function useToast() {	// 后代组件可以从该方法中拿到 toast 方法\r\n    const toast = inject(ToastSymbol);\r\n    if (!toast) {\r\n        throw new Error(\'error\');\r\n    }\r\n    return toast;\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n', '<p>在信息安全越来越受重视的今天，前端的各种加密也变得更加重要。通常跟服务器的交互中，为保障数据传输的安全性，避免被人抓包篡改数据，除了 https 的应用，还需要对传输数据进行加解密。</p>\n<p>目前常见的加密算法可以分成三类</p>\n<ul>\n<li>对称加密算法：AES、…</li>\n<li>非对称加密算法：RSA、…</li>\n<li>Hash 算法：MD5、…</li>\n</ul>\n<p><strong>二、对称加密算法</strong><br />\n对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信的安全性至关重要。</p>\n<p><strong>特点</strong><br />\n优点：算法公开、计算量小、加密速度快、加密效率高。<br />\n缺点：在数据传送前，发送方和接收方必须商定好密钥，然后双方保存好密钥。如果一方的密钥被泄露，那么加密信息也就不安全了<br />\n使用场景：本地数据加密、https 通信、网络传输等<br />\n<strong>AES</strong><br />\nAES：高级加密标准(Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。<br />\n密钥：用来加密明文的密码。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取数据。</p>', '服务端', 'PHP,Python', '2020-02-12 11:47:25', NULL);

-- ----------------------------
-- Table structure for sort
-- ----------------------------
DROP TABLE IF EXISTS `sort`;
CREATE TABLE `sort`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `sort_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp(0) NULL DEFAULT NULL,
  `updated_at` timestamp(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sort
-- ----------------------------
INSERT INTO `sort` VALUES (1, '前端', '2020-08-12 08:50:43', '2020-08-17 10:08:51');
INSERT INTO `sort` VALUES (2, '后端', '2020-08-12 08:50:43', '2020-08-12 08:50:43');
INSERT INTO `sort` VALUES (3, '服务端', '2020-08-12 08:50:43', NULL);

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp(0) NULL DEFAULT NULL,
  `updated_at` timestamp(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, 'JAVA', '2020-08-12 08:51:00', '2020-08-17 09:51:39');
INSERT INTO `tag` VALUES (2, 'PHP', '2020-08-12 08:51:00', '2020-08-12 08:51:00');
INSERT INTO `tag` VALUES (3, 'Mysql', '2020-08-12 08:51:00', '2020-08-12 08:51:00');
INSERT INTO `tag` VALUES (4, 'Javascript', '2020-08-12 08:51:00', '2020-08-12 08:51:00');
INSERT INTO `tag` VALUES (5, 'Python', '2020-08-12 08:51:00', '2020-08-12 08:51:00');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '用户名',
  `password` varchar(225) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '密码',
  `last_login_time` datetime(0) NULL DEFAULT NULL COMMENT '上次登录时间',
  `token` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `created_at` timestamp(0) NULL DEFAULT NULL,
  `updated_at` timestamp(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'admin', 'e10adc3949ba59abbe56e057f20f883e', '2020-08-17 21:22:15', NULL, '2020-08-12 11:47:25', '2020-08-12 21:57:15');
INSERT INTO `user` VALUES (2, '8963', '79c90275439ae4a0fe9817842e668e7c', '2020-08-15 15:15:49', NULL, '2020-08-12 11:47:25', '2020-08-12 22:05:00');

SET FOREIGN_KEY_CHECKS = 1;
